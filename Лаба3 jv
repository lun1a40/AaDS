1 Бинарная куча 
import java.util.*;

public class BinaryHeap<T extends Comparable<T>> {
    private List<T> heap;
    
    public BinaryHeap() {
        heap = new ArrayList<>();
    }
    
    private void heapifyUp(int index) {
        while (index > 0 && heap.get(parent(index)).compareTo(heap.get(index)) > 0) {
            Collections.swap(heap, parent(index), index);
            index = parent(index);
        }
    }
    
    private void heapifyDown(int index) {
        int minIndex = index;
        int left = leftChild(index);
        int right = rightChild(index);
        
        if (left < heap.size() && heap.get(left).compareTo(heap.get(minIndex)) < 0)
            minIndex = left;
        if (right < heap.size() && heap.get(right).compareTo(heap.get(minIndex)) < 0)
            minIndex = right;
            
        if (index != minIndex) {
            Collections.swap(heap, index, minIndex);
            heapifyDown(minIndex);
        }
    }
    
    private int parent(int i) { return (i - 1) / 2; }
    private int leftChild(int i) { return 2 * i + 1; }
    private int rightChild(int i) { return 2 * i + 2; }
    
    public void insert(T value) {
        heap.add(value);
        heapifyUp(heap.size() - 1);
    }
    
    public T extractMin() {
        if (heap.isEmpty()) throw new NoSuchElementException("Heap is empty");
        T min = heap.get(0);
        heap.set(0, heap.get(heap.size() - 1));public class BinomialHeap<T extends Comparable<T>> {
    private static class Node<T> {
        T key;
        int degree;
        Node<T> parent;
        Node<T> child;
        Node<T> sibling;
        
        Node(T key) {
            this.key = key;
            this.degree = 0;
        }
    }
    
    private Node<T> head;
    
    private Node<T> mergeTrees(Node<T> a, Node<T> b) {
        if (a.key.compareTo(b.key) > 0) {
            Node<T> temp = a;
            a = b;
            b = temp;
        }
        b.parent = a;
        b.sibling = a.child;
        a.child = b;
        a.degree++;
        return a;
    }
    
    private Node<T> mergeHeaps(Node<T> h1, Node<T> h2) {
        if (h1 == null) return h2;
        if (h2 == null) return h1;
        
        Node<T> newHead = null;
        Node<T> current = null;
        
        while (h1 != null && h2 != null) {
            Node<T> node;
            if (h1.degree <= h2.degree) {
                node = h1;
                h1 = h1.sibling;
            } else {
                node = h2;
                h2 = h2.sibling;
            }
            
            if (newHead == null) {
                newHead = node;
                current = node;
            } else {
                current.sibling = node;
                current = node;
            }
        }
        
        current.sibling = (h1 != null) ? h1 : h2;
        return newHead;
    }
    
    private void unionHeap(Node<T> other) {
        head = mergeHeaps(head, other);
        if (head == null) return;
        
        Node<T> prev = null;
        Node<T> curr = head;
        Node<T> next = curr.sibling;
        
        while (next != null) {
            if (curr.degree != next.degree || 
                (next.sibling != null && next.sibling.degree == curr.degree)) {
                prev = curr;
                curr = next;
            } else if (curr.key.compareTo(next.key) <= 0) {
                curr.sibling = next.sibling;
                mergeTrees(curr, next);
            } else {
                if (prev == null) head = next;
                else prev.sibling = next;
                mergeTrees(next, curr);
                curr = next;
            }
            next = curr.sibling;
        }
    }
    
    public void insert(T key) {
        Node<T> node = new Node<>(key);
        unionHeap(node);
    }
    
    public T getMinimum() {
        if (head == null) throw new NoSuchElementException("Heap is empty");
        
        Node<T> minNode = head;
        Node<T> current = head.sibling;
        
        while (current != null) {
            if (current.key.compareTo(minNode.key) < 0)
                minNode = current;
            current = current.sibling;
        }
        return minNode.key;
    }
}
3 Хэш таблица 
import java.util.*;

public class HashMap<K, V> {
    private static class Entry<K, V> {
        final K key;
        V value;
        Entry<K, V> next;
        
        Entry(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }
    
    private Entry<K, V>[] buckets;
    private int size;
    private final double loadFactorThreshold;
    private static final int DEFAULT_CAPACITY = 16;
    private static final double DEFAULT_LOAD_FACTOR = 0.75;
    
    @SuppressWarnings("unchecked")
    public HashMap() {
        this.buckets = new Entry[DEFAULT_CAPACITY];
        this.loadFactorThreshold = DEFAULT_LOAD_FACTOR;
    }
    
    private int hash(K key) {
        return key == null ? 0 : Math.abs(key.hashCode()) % buckets.length;
    }
    
    private void rehash() {
        Entry<K, V>[] oldBuckets = buckets;
        @SuppressWarnings("unchecked")
        Entry<K, V>[] newBuckets = new Entry[oldBuckets.length * 2];
        buckets = newBuckets;
        size = 0;
        
        for (Entry<K, V> entry : oldBuckets) {
            while (entry != null) {
                put(entry.key, entry.value);
                entry = entry.next;
            }
        }
    }
    
    public void put(K key, V value) {
        if (loadFactor() > loadFactorThreshold) {
            rehash();
        }
        
        int index = hash(key);
        Entry<K, V> entry = buckets[index];
        
        while (entry != null) {
            if (Objects.equals(entry.key, key)) {
                entry.value = value;
                return;
            }
            entry = entry.next;
        }
        
        Entry<K, V> newEntry = new Entry<>(key, value);
        newEntry.next = buckets[index];
        buckets[index] = newEntry;
        size++;
    }
    
    public V get(K key) {
        int index = hash(key);
        Entry<K, V> entry = buckets[index];
        
        while (entry != null) {
            if (Objects.equals(entry.key, key)) {
                return entry.value;
            }
            entry = entry.next;
        }
        return null;
    }
    
    public boolean remove(K key) {
        int index = hash(key);
        Entry<K, V> entry = buckets[index];
        Entry<K, V> prev = null;
        
        while (entry != null) {
            if (Objects.equals(entry.key, key)) {
                if (prev == null) {
                    buckets[index] = entry.next;
                } else {
                    prev.next = entry.next;
                }
                size--;
                return true;
            }
            prev = entry;
            entry = entry.next;
        }
        return false;
    }
    
    private double loadFactor() {
        return (double) size / buckets.length;
    }
    
    public int size() { return size; }
    public boolean isEmpty() { return size == 0; }
}
        heap.remove(heap.size() - 1);
        if (!heap.isEmpty()) heapifyDown(0);
        return min;
    }
    
    public T getMin() { return heap.get(0); }
    public boolean isEmpty() { return heap.isEmpty(); }
    public int size() { return heap.size(); }
}
2 Биномиальная куча
