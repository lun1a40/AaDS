Биномиальная куча 
#include <vector>
#include <algorithm>

template<typename T>
class BinaryHeap {
private:
    std::vector<T> heap;
    
    void heapifyUp(int index) {
        while (index > 0 && heap[parent(index)] > heap[index]) {
            std::swap(heap[parent(index)], heap[index]);
            index = parent(index);
        }
    }
    
    void heapifyDown(int index) {
        int minIndex = index;
        int left = leftChild(index);
        int right = rightChild(index);
        
        if (left < heap.size() && heap[left] < heap[minIndex])
            minIndex = left;
        if (right < heap.size() && heap[right] < heap[minIndex])
            minIndex = right;
            
        if (index != minIndex) {
            std::swap(heap[index], heap[minIndex]);
            heapifyDown(minIndex);
        }
    }
    
    int parent(int i) { return (i - 1) / 2; }
    int leftChild(int i) { return 2 * i + 1; }
    int rightChild(int i) { return 2 * i + 2; }

public:
    void insert(const T& value) {
        heap.push_back(value);
        heapifyUp(heap.size() - 1);
    }
    
    T extractMin() {
        if (heap.empty()) throw std::runtime_error("Heap is empty");
        T min = heap[0];
        heap[0] = heap.back();
        heap.pop_back();
        if (!heap.empty()) heapifyDown(0);
        return min;
    }
    
    const T& getMin() const { return heap[0]; }
    bool empty() const { return heap.empty(); }
    size_t size() const { return heap.size(); }
};
2 Хэш-таблица
#include <vector>
#include <list>
#include <functional>

template<typename K, typename V>
class HashMap {
private:
    struct KeyValue {
        K key;
        V value;
        KeyValue(const K& k, const V& v) : key(k), value(v) {}
    };
    
    std::vector<std::list<KeyValue>> buckets;
    size_t numElements;
    double loadFactorThreshold;
    
    size_t hash(const K& key) const {
        return std::hash<K>{}(key) % buckets.size();
    }
    
    void rehash() {
        std::vector<std::list<KeyValue>> oldBuckets = std::move(buckets);
        buckets.resize(oldBuckets.size() * 2);
        numElements = 0;
        
        for (auto& bucket : oldBuckets) {
            for (auto& kv : bucket) {
                insert(kv.key, kv.value);
            }
        }
    }

public:
    HashMap(size_t initialSize = 16, double lfThreshold = 0.75) 
        : buckets(initialSize), numElements(0), loadFactorThreshold(lfThreshold) {}
    
    void insert(const K& key, const V& value) {
        if (loadFactor() > loadFactorThreshold) {
            rehash();
        }
        
        size_t index = hash(key);
        for (auto& kv : buckets[index]) {
            if (kv.key == key) {
                kv.value = value;
                return;
            }
        }
        
        buckets[index].emplace_back(key, value);
        numElements++;
    }
    
    V* get(const K& key) {
        size_t index = hash(key);
        for (auto& kv : buckets[index]) {
            if (kv.key == key) {
                return &kv.value;
            }
        }
        return nullptr;
    }
    
    bool remove(const K& key) {
        size_t index = hash(key);
        auto& bucket = buckets[index];
        
        for (auto it = bucket.begin(); it != bucket.end(); ++it) {
            if (it->key == key) {
                bucket.erase(it);
                numElements--;
                return true;
            }
        }
        return false;
    }
    
    double loadFactor() const {
        return static_cast<double>(numElements) / buckets.size();
    }
    
    size_t size() const { return numElements; }
    bool empty() const { return numElements == 0; }
};
