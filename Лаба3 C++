1 Бинарная куча 
#include <vector>
#include <algorithm>

template<typename T>
class BinaryHeap {
private:
    std::vector<T> heap;
    
    void heapifyUp(int index) {
        while (index > 0 && heap[parent(index)] > heap[index]) {
            std::swap(heap[parent(index)], heap[index]);
            index = parent(index);
        }
    }
    
    void heapifyDown(int index) {
        int minIndex = index;
        int left = leftChild(index);
        int right = rightChild(index);
        
        if (left < heap.size() && heap[left] < heap[minIndex])
            minIndex = left;
        if (right < heap.size() && heap[right] < heap[minIndex])
            minIndex = right;
            
        if (index != minIndex) {
            std::swap(heap[index], heap[minIndex]);
            heapifyDown(minIndex);
        }
    }
    
    int parent(int i) { return (i - 1) / 2; }
    int leftChild(int i) { return 2 * i + 1; }
    int rightChild(int i) { return 2 * i + 2; }

public:
    void insert(const T& value) {
        heap.push_back(value);
        heapifyUp(heap.size() - 1);
    }
    
    T extractMin() {
        if (heap.empty()) throw std::runtime_error("Heap is empty");
        T min = heap[0];
        heap[0] = heap.back();
        heap.pop_back();
        if (!heap.empty()) heapifyDown(0);
        return min;
    }
    
    const T& getMin() const { return heap[0]; }
    bool empty() const { return heap.empty(); }
    size_t size() const { return heap.size(); }
};
2 Биномиальная куча
#include <vector>
#include <algorithm>

template<typename T>
class BinomialHeap {
private:
    struct Node {
        T key;
        int degree;
        Node* parent;
        Node* child;
        Node* sibling;
        
        Node(T k) : key(k), degree(0), parent(nullptr), 
                   child(nullptr), sibling(nullptr) {}
    };
    
    Node* head;
    
    Node* mergeTrees(Node* a, Node* b) {
        if (a->key > b->key) std::swap(a, b);
        b->parent = a;
        b->sibling = a->child;
        a->child = b;
        a->degree++;
        return a;
    }
    
    Node* mergeHeaps(Node* h1, Node* h2) {
        if (!h1) return h2;
        if (!h2) return h1;
        
        Node* newHead = nullptr;
        Node** current = &newHead;
        
        while (h1 && h2) {
            if (h1->degree <= h2->degree) {
                *current = h1;
                h1 = h1->sibling;
            } else {
                *current = h2;
                h2 = h2->sibling;
            }
            current = &((*current)->sibling);
        }
        
        *current = h1 ? h1 : h2;
        return newHead;
    }
    
    void unionHeap(Node* other) {
        head = mergeHeaps(head, other);
        if (!head) return;
        
        Node* prev = nullptr;
        Node* curr = head;
        Node* next = curr->sibling;
        
        while (next) {
            if (curr->degree != next->degree || 
                (next->sibling && next->sibling->degree == curr->degree)) {
                prev = curr;
                curr = next;
            } else if (curr->key <= next->key) {
                curr->sibling = next->sibling;
                mergeTrees(curr, next);
            } else {
                if (!prev) head = next;
                else prev->sibling = next;
                mergeTrees(next, curr);
                curr = next;
            }
            next = curr->sibling;
        }
    }

public:
    BinomialHeap() : head(nullptr) {}
    
    void insert(const T& key) {
        BinomialHeap temp;
        temp.head = new Node(key);
        unionHeap(temp.head);
        temp.head = nullptr;
    }
    
    T getMinimum() {
        if (!head) throw std::runtime_error("Heap is empty");
        
        Node* minNode = head;
        Node* current = head->sibling;
        
        while (current) {
            if (current->key < minNode->key)
                minNode = current;
            current = current->sibling;
        }
        return minNode->key;
    }
    
    // Другие методы опущены для краткости
};
3 Хэш-таблица
#include <vector>
#include <list>
#include <functional>

template<typename K, typename V>
class HashMap {
private:
    struct KeyValue {
        K key;
        V value;
        KeyValue(const K& k, const V& v) : key(k), value(v) {}
    };
    
    std::vector<std::list<KeyValue>> buckets;
    size_t numElements;
    double loadFactorThreshold;
    
    size_t hash(const K& key) const {
        return std::hash<K>{}(key) % buckets.size();
    }
    
    void rehash() {
        std::vector<std::list<KeyValue>> oldBuckets = std::move(buckets);
        buckets.resize(oldBuckets.size() * 2);
        numElements = 0;
        
        for (auto& bucket : oldBuckets) {
            for (auto& kv : bucket) {
                insert(kv.key, kv.value);
            }
        }
    }

public:
    HashMap(size_t initialSize = 16, double lfThreshold = 0.75) 
        : buckets(initialSize), numElements(0), loadFactorThreshold(lfThreshold) {}
    
    void insert(const K& key, const V& value) {
        if (loadFactor() > loadFactorThreshold) {
            rehash();
        }
        
        size_t index = hash(key);
        for (auto& kv : buckets[index]) {
            if (kv.key == key) {
                kv.value = value;
                return;
            }
        }
        
        buckets[index].emplace_back(key, value);
        numElements++;
    }
    
    V* get(const K& key) {
        size_t index = hash(key);
        for (auto& kv : buckets[index]) {
            if (kv.key == key) {
                return &kv.value;
            }
        }
        return nullptr;
    }
    
    bool remove(const K& key) {
        size_t index = hash(key);
        auto& bucket = buckets[index];
        
        for (auto it = bucket.begin(); it != bucket.end(); ++it) {
            if (it->key == key) {
                bucket.erase(it);
                numElements--;
                return true;
            }
        }
        return false;
    }
    
    double loadFactor() const {
        return static_cast<double>(numElements) / buckets.size();
    }
    
    size_t size() const { return numElements; }
    bool empty() const { return numElements == 0; }
};
